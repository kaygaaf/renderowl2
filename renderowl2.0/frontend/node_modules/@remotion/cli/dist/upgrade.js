"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgradeCommand = void 0;
const node_child_process_1 = require("node:child_process");
const renderer_1 = require("@remotion/renderer");
const studio_server_1 = require("@remotion/studio-server");
const catalog_utils_1 = require("./catalog-utils");
const chalk_1 = require("./chalk");
const extra_packages_1 = require("./extra-packages");
const list_of_remotion_packages_1 = require("./list-of-remotion-packages");
const log_1 = require("./log");
const getExtraPackageVersionsForRemotionVersion = (remotionVersion) => {
    try {
        const output = (0, node_child_process_1.execSync)(`npm view @remotion/studio@${remotionVersion} dependencies --json`, { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] });
        const dependencies = JSON.parse(output);
        const extraVersions = {};
        for (const pkg of Object.keys(extra_packages_1.EXTRA_PACKAGES)) {
            if (dependencies[pkg]) {
                extraVersions[pkg] = dependencies[pkg];
            }
        }
        return extraVersions;
    }
    catch (_a) {
        // If we can't fetch the versions, return the default versions from EXTRA_PACKAGES
        return extra_packages_1.EXTRA_PACKAGES;
    }
};
const upgradeCommand = async ({ remotionRoot, packageManager, version, logLevel, args, }) => {
    var _a;
    const depsWithVersions = studio_server_1.StudioServerInternals.getInstalledDependenciesWithVersions(remotionRoot);
    let targetVersion;
    if (version) {
        targetVersion = version;
        log_1.Log.info({ indent: false, logLevel }, 'Upgrading to specified version: ' + version);
    }
    else {
        targetVersion = await studio_server_1.StudioServerInternals.getLatestRemotionVersion();
        log_1.Log.info({ indent: false, logLevel }, 'Newest Remotion version is', targetVersion);
    }
    const manager = studio_server_1.StudioServerInternals.getPackageManager({
        remotionRoot,
        packageManager,
        dirUp: 0,
        logLevel,
    });
    if (manager === 'unknown') {
        throw new Error(`No lockfile was found in your project (one of ${studio_server_1.StudioServerInternals.lockFilePaths
            .map((p) => p.path)
            .join(', ')}). Install dependencies using your favorite manager!`);
    }
    const allDeps = [
        ...Object.keys(depsWithVersions.dependencies),
        ...Object.keys(depsWithVersions.devDependencies),
        ...Object.keys(depsWithVersions.optionalDependencies),
        ...Object.keys(depsWithVersions.peerDependencies),
    ];
    const remotionToUpgrade = list_of_remotion_packages_1.listOfRemotionPackages.filter((u) => allDeps.includes(u));
    const installedExtraPackages = Object.keys(extra_packages_1.EXTRA_PACKAGES).filter((pkg) => allDeps.includes(pkg));
    const extraPackageVersions = getExtraPackageVersionsForRemotionVersion(targetVersion);
    if (installedExtraPackages.length > 0) {
        log_1.Log.info({ indent: false, logLevel }, `Also upgrading extra packages: ${installedExtraPackages.map((pkg) => `${pkg}@${extraPackageVersions[pkg]}`).join(', ')}`);
    }
    const allPackagesToUpgrade = [
        ...remotionToUpgrade,
        ...installedExtraPackages,
    ];
    const normalPackages = [];
    const catalogPackages = [];
    for (const pkg of allPackagesToUpgrade) {
        const versionSpec = (0, catalog_utils_1.findVersionSpecifier)(depsWithVersions, pkg);
        const targetVersionForPkg = (_a = extraPackageVersions[pkg]) !== null && _a !== void 0 ? _a : targetVersion;
        if (versionSpec && (0, catalog_utils_1.isCatalogProtocol)(versionSpec)) {
            catalogPackages.push({ pkg, version: targetVersionForPkg });
        }
        else {
            normalPackages.push({ pkg, version: targetVersionForPkg });
        }
    }
    if (catalogPackages.length > 0) {
        const workspaceRoot = (0, catalog_utils_1.findWorkspaceRoot)(remotionRoot);
        if (workspaceRoot) {
            const updatedCatalogEntries = [];
            for (const { pkg, version: pkgVersion } of catalogPackages) {
                const didUpdate = (0, catalog_utils_1.updateCatalogEntry)({
                    workspaceRoot,
                    pkg,
                    newVersion: pkgVersion,
                });
                if (didUpdate) {
                    updatedCatalogEntries.push(`${pkg}@${pkgVersion}`);
                }
                else {
                    normalPackages.push({ pkg, version: pkgVersion });
                }
            }
            if (updatedCatalogEntries.length > 0) {
                log_1.Log.info({ indent: false, logLevel }, chalk_1.chalk.green(`Updated catalog entries: ${updatedCatalogEntries.join(', ')}`));
            }
        }
        else {
            for (const catalogPkg of catalogPackages) {
                normalPackages.push(catalogPkg);
            }
        }
    }
    const packagesWithVersions = normalPackages.map(({ pkg, version: pkgVersion }) => `${pkg}@${pkgVersion}`);
    if (packagesWithVersions.length > 0) {
        const command = studio_server_1.StudioServerInternals.getInstallCommand({
            manager: manager.manager,
            packages: packagesWithVersions,
            version: '',
            additionalArgs: args,
        });
        log_1.Log.info({ indent: false, logLevel }, chalk_1.chalk.gray(`$ ${manager.manager} ${command.join(' ')}`));
        await runPackageManagerCommand({
            manager: manager.manager,
            command,
            logLevel,
        });
    }
    if (catalogPackages.length > 0 && packagesWithVersions.length === 0) {
        log_1.Log.info({ indent: false, logLevel }, chalk_1.chalk.gray(`$ ${manager.manager} install`));
        await runPackageManagerCommand({
            manager: manager.manager,
            command: ['install'],
            logLevel,
        });
    }
    log_1.Log.info({ indent: false, logLevel }, 'â« Remotion has been upgraded!');
    log_1.Log.info({ indent: false, logLevel }, 'https://remotion.dev/changelog');
};
exports.upgradeCommand = upgradeCommand;
const runPackageManagerCommand = async ({ manager, command, logLevel, }) => {
    const task = (0, node_child_process_1.spawn)(manager, command, {
        env: {
            ...process.env,
            ADBLOCK: '1',
            DISABLE_OPENCOLLECTIVE: '1',
        },
        stdio: renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'info')
            ? 'inherit'
            : 'ignore',
    });
    await new Promise((resolve) => {
        task.on('close', (code) => {
            if (code === 0) {
                resolve();
            }
            else if (renderer_1.RenderInternals.isEqualOrBelowLogLevel(logLevel, 'info')) {
                throw new Error('Failed to upgrade Remotion, see logs above');
            }
            else {
                throw new Error('Failed to upgrade Remotion, run with --log=info info to see logs');
            }
        });
    });
};
