"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeSequencePropsStatus = exports.extractStaticValue = exports.isStaticValue = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const recast = __importStar(require("recast"));
const parse_ast_1 = require("../../codemods/parse-ast");
const isStaticValue = (node) => {
    switch (node.type) {
        case 'NumericLiteral':
        case 'StringLiteral':
        case 'BooleanLiteral':
        case 'NullLiteral':
            return true;
        case 'UnaryExpression':
            return ((node.operator === '-' ||
                node.operator === '+') &&
                node.argument.type === 'NumericLiteral');
        case 'ArrayExpression':
            return node.elements.every((el) => el !== null && el.type !== 'SpreadElement' && (0, exports.isStaticValue)(el));
        case 'ObjectExpression':
            return node.properties.every((prop) => prop.type === 'ObjectProperty' &&
                (0, exports.isStaticValue)(prop.value));
        default:
            return false;
    }
};
exports.isStaticValue = isStaticValue;
const extractStaticValue = (node) => {
    switch (node.type) {
        case 'NumericLiteral':
        case 'StringLiteral':
        case 'BooleanLiteral':
            return node.value;
        case 'NullLiteral':
            return null;
        case 'UnaryExpression': {
            const un = node;
            if (un.argument.type === 'NumericLiteral') {
                const val = un.argument.value;
                return un.operator === '-' ? -val : val;
            }
            return undefined;
        }
        case 'ArrayExpression':
            return node.elements.map((el) => {
                if (el === null || el.type === 'SpreadElement') {
                    return undefined;
                }
                return (0, exports.extractStaticValue)(el);
            });
        case 'ObjectExpression': {
            const obj = node;
            const result = {};
            for (const prop of obj.properties) {
                if (prop.type === 'ObjectProperty') {
                    const p = prop;
                    const key = p.key.type === 'Identifier'
                        ? p.key.name
                        : p.key.type === 'StringLiteral' ||
                            p.key.type === 'NumericLiteral'
                            ? String(p.key.value)
                            : undefined;
                    if (key !== undefined) {
                        result[key] = (0, exports.extractStaticValue)(p.value);
                    }
                }
            }
            return result;
        }
        default:
            return undefined;
    }
};
exports.extractStaticValue = extractStaticValue;
const getPropsStatus = (jsxElement) => {
    const props = {};
    for (const attr of jsxElement.attributes) {
        if (attr.type === 'JSXSpreadAttribute') {
            continue;
        }
        if (attr.name.type === 'JSXNamespacedName') {
            continue;
        }
        const { name } = attr.name;
        if (typeof name !== 'string') {
            continue;
        }
        const { value } = attr;
        if (!value) {
            props[name] = { canUpdate: true, codeValue: true };
            continue;
        }
        if (value.type === 'StringLiteral') {
            props[name] = {
                canUpdate: true,
                codeValue: value.value,
            };
            continue;
        }
        if (value.type === 'JSXExpressionContainer') {
            const { expression } = value;
            if (expression.type === 'JSXEmptyExpression' ||
                !(0, exports.isStaticValue)(expression)) {
                props[name] = { canUpdate: false, reason: 'computed' };
                continue;
            }
            props[name] = {
                canUpdate: true,
                codeValue: (0, exports.extractStaticValue)(expression),
            };
            continue;
        }
        props[name] = { canUpdate: false, reason: 'computed' };
    }
    return props;
};
const findJsxElementAtLine = (ast, targetLine) => {
    let found = null;
    recast.types.visit(ast, {
        visitJSXOpeningElement(nodePath) {
            const { node } = nodePath;
            if (node.loc && node.loc.start.line === targetLine) {
                found = node;
                return false;
            }
            return this.traverse(nodePath);
        },
    });
    return found;
};
const computeSequencePropsStatus = ({ fileName, line, keys, remotionRoot, }) => {
    try {
        const absolutePath = node_path_1.default.resolve(remotionRoot, fileName);
        const fileRelativeToRoot = node_path_1.default.relative(remotionRoot, absolutePath);
        if (fileRelativeToRoot.startsWith('..')) {
            throw new Error('Cannot read a file outside the project');
        }
        const fileContents = (0, node_fs_1.readFileSync)(absolutePath, 'utf-8');
        const ast = (0, parse_ast_1.parseAst)(fileContents);
        const jsxElement = findJsxElementAtLine(ast, line);
        if (!jsxElement) {
            throw new Error('Could not find a JSX element at the specified location');
        }
        const allProps = getPropsStatus(jsxElement);
        const filteredProps = {};
        for (const key of keys) {
            if (key in allProps) {
                filteredProps[key] = allProps[key];
            }
            else {
                filteredProps[key] = { canUpdate: true, codeValue: undefined };
            }
        }
        return {
            canUpdate: true,
            props: filteredProps,
        };
    }
    catch (err) {
        return {
            canUpdate: false,
            reason: err.message,
        };
    }
};
exports.computeSequencePropsStatus = computeSequencePropsStatus;
