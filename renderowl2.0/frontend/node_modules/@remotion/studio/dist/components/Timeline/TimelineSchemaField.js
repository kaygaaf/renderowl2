"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimelineFieldSavingSpinner = exports.TimelineFieldValue = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const Checkbox_1 = require("../Checkbox");
const InputDragger_1 = require("../NewComposition/InputDragger");
const Spinner_1 = require("../Spinner");
const unsupportedLabel = {
    color: 'rgba(255, 255, 255, 0.4)',
    fontSize: 12,
    marginLeft: 'auto',
    fontStyle: 'italic',
};
const draggerStyle = {
    width: 80,
    marginLeft: 'auto',
};
const checkboxContainer = {
    marginLeft: 'auto',
};
const notEditableBackground = {
    backgroundColor: 'rgba(255, 0, 0, 0.2)',
    borderRadius: 3,
    padding: '0 4px',
};
const TimelineNumberField = ({ field, codeValue, canUpdate, onSave, onDragValueChange, onDragEnd }) => {
    var _a, _b, _c;
    const [dragValue, setDragValue] = (0, react_1.useState)(null);
    const dragging = (0, react_1.useRef)(false);
    const onValueChange = (0, react_1.useCallback)((newVal) => {
        dragging.current = true;
        setDragValue(newVal);
        onDragValueChange(field.key, newVal);
    }, [onDragValueChange, field.key]);
    (0, react_1.useEffect)(() => {
        setDragValue(null);
        onDragEnd();
    }, [field.currentValue, onDragEnd]);
    const onValueChangeEnd = (0, react_1.useCallback)((newVal) => {
        if (canUpdate && newVal !== codeValue) {
            onSave(field.key, newVal).catch(() => {
                setDragValue(null);
            });
        }
        else {
            setDragValue(null);
        }
    }, [canUpdate, onSave, field.key, codeValue]);
    const onTextChange = (0, react_1.useCallback)((newVal) => {
        if (canUpdate) {
            const parsed = Number(newVal);
            if (!Number.isNaN(parsed) && parsed !== codeValue) {
                setDragValue(parsed);
                onSave(field.key, parsed).catch(() => {
                    setDragValue(null);
                });
            }
        }
    }, [canUpdate, onSave, field.key, codeValue]);
    return (jsx_runtime_1.jsx(InputDragger_1.InputDragger, { type: "number", value: dragValue !== null && dragValue !== void 0 ? dragValue : codeValue, style: draggerStyle, status: "ok", onValueChange: onValueChange, onValueChangeEnd: onValueChangeEnd, onTextChange: onTextChange, min: field.fieldSchema.type === 'number'
            ? ((_a = field.fieldSchema.min) !== null && _a !== void 0 ? _a : -Infinity)
            : -Infinity, max: field.fieldSchema.type === 'number'
            ? ((_b = field.fieldSchema.max) !== null && _b !== void 0 ? _b : Infinity)
            : Infinity, step: field.fieldSchema.type === 'number' ? ((_c = field.fieldSchema.step) !== null && _c !== void 0 ? _c : 1) : 1, rightAlign: true }));
};
const TimelineBooleanField = ({ field, codeValue, canUpdate, onSave }) => {
    const checked = Boolean(codeValue);
    const onChange = (0, react_1.useCallback)(() => {
        if (canUpdate) {
            onSave(field.key, !checked);
        }
    }, [canUpdate, onSave, field.key, checked]);
    return (jsx_runtime_1.jsx("div", { style: checkboxContainer, children: jsx_runtime_1.jsx(Checkbox_1.Checkbox, { checked: checked, onChange: onChange, name: field.key, disabled: !canUpdate }) }));
};
const TimelineFieldValue = ({ field, onSave, onDragValueChange, onDragEnd, propStatus, canUpdate }) => {
    var _a, _b;
    const wrapperStyle = canUpdate === null || canUpdate === false
        ? notEditableBackground
        : undefined;
    if (!field.supported) {
        return jsx_runtime_1.jsx("span", { style: unsupportedLabel, children: "unsupported" });
    }
    if (propStatus !== null && !propStatus.canUpdate) {
        return jsx_runtime_1.jsx("span", { style: unsupportedLabel, children: propStatus.reason });
    }
    if (propStatus === null) {
        return (jsx_runtime_1.jsx("span", { style: { ...notEditableBackground }, children: jsx_runtime_1.jsx("span", { style: unsupportedLabel, children: "error" }) }));
    }
    const effectiveCodeValue = (_b = (_a = propStatus.codeValue) !== null && _a !== void 0 ? _a : field.currentValue) !== null && _b !== void 0 ? _b : field.fieldSchema.default;
    if (field.typeName === 'number') {
        return (jsx_runtime_1.jsx("span", { style: wrapperStyle, children: jsx_runtime_1.jsx(TimelineNumberField, { field: field, codeValue: effectiveCodeValue, canUpdate: canUpdate, onSave: onSave, onDragValueChange: onDragValueChange, onDragEnd: onDragEnd }) }));
    }
    if (field.typeName === 'boolean') {
        return (jsx_runtime_1.jsx("span", { style: wrapperStyle, children: jsx_runtime_1.jsx(TimelineBooleanField, { field: field, codeValue: effectiveCodeValue, canUpdate: canUpdate, onSave: onSave }) }));
    }
    return (jsx_runtime_1.jsx("span", { style: { ...unsupportedLabel, fontStyle: 'normal' }, children: String(effectiveCodeValue) }));
};
exports.TimelineFieldValue = TimelineFieldValue;
const TimelineFieldSavingSpinner = ({ saving }) => {
    if (!saving) {
        return null;
    }
    return jsx_runtime_1.jsx(Spinner_1.Spinner, { duration: 0.5, size: 12 });
};
exports.TimelineFieldSavingSpinner = TimelineFieldSavingSpinner;
