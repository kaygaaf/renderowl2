"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimelineFieldSavingSpinner = exports.TimelineFieldValue = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const InputDragger_1 = require("../NewComposition/InputDragger");
const zod_number_constraints_1 = require("../RenderModal/SchemaEditor/zod-number-constraints");
const Spinner_1 = require("../Spinner");
const unsupportedLabel = {
    color: 'rgba(255, 255, 255, 0.4)',
    fontSize: 12,
    marginLeft: 'auto',
    fontStyle: 'italic',
};
const draggerStyle = {
    width: 80,
    marginLeft: 'auto',
};
const notEditableBackground = {
    backgroundColor: 'rgba(255, 0, 0, 0.2)',
    borderRadius: 3,
    padding: '0 4px',
};
const TimelineNumberField = ({ field, canUpdate, onSave, onSavingChange, onDragValueChange, onDragEnd, }) => {
    const [dragValue, setDragValue] = (0, react_1.useState)(null);
    const dragging = (0, react_1.useRef)(false);
    const onValueChange = (0, react_1.useCallback)((newVal) => {
        dragging.current = true;
        setDragValue(newVal);
        onDragValueChange(field.key, newVal);
    }, [onDragValueChange, field.key]);
    (0, react_1.useEffect)(() => {
        setDragValue(null);
        onSavingChange(false);
        onDragEnd();
    }, [field.currentValue, onSavingChange, onDragEnd]);
    const onValueChangeEnd = (0, react_1.useCallback)((newVal) => {
        if (canUpdate && newVal !== field.currentValue) {
            onSavingChange(true);
            onSave(field.key, newVal).catch(() => {
                onSavingChange(false);
                setDragValue(null);
            });
        }
        else {
            setDragValue(null);
        }
    }, [canUpdate, onSave, onSavingChange, field.key, field.currentValue]);
    const onTextChange = (0, react_1.useCallback)((newVal) => {
        if (canUpdate) {
            const parsed = Number(newVal);
            if (!Number.isNaN(parsed) && parsed !== field.currentValue) {
                setDragValue(parsed);
                onSavingChange(true);
                onSave(field.key, parsed).catch(() => {
                    onSavingChange(false);
                    setDragValue(null);
                });
            }
        }
    }, [canUpdate, onSave, onSavingChange, field.key, field.currentValue]);
    return (jsx_runtime_1.jsx(InputDragger_1.InputDragger, { type: "number", value: dragValue !== null && dragValue !== void 0 ? dragValue : field.currentValue, style: draggerStyle, status: "ok", onValueChange: onValueChange, onValueChangeEnd: onValueChangeEnd, onTextChange: onTextChange, min: (0, zod_number_constraints_1.getZodNumberMinimum)(field.fieldSchema), max: (0, zod_number_constraints_1.getZodNumberMaximum)(field.fieldSchema), step: (0, zod_number_constraints_1.getZodNumberStep)(field.fieldSchema), rightAlign: true }));
};
const TimelineFieldValue = ({ field, onSave, onSavingChange, onDragValueChange, onDragEnd, propStatus, canUpdate, }) => {
    const wrapperStyle = canUpdate === null || canUpdate === false
        ? notEditableBackground
        : undefined;
    if (!field.supported) {
        return jsx_runtime_1.jsx("span", { style: unsupportedLabel, children: "unsupported" });
    }
    if (propStatus !== null && !propStatus.canUpdate) {
        return jsx_runtime_1.jsx("span", { style: unsupportedLabel, children: propStatus.reason });
    }
    if (propStatus === null) {
        return (jsx_runtime_1.jsx("span", { style: { ...notEditableBackground }, children: jsx_runtime_1.jsx("span", { style: unsupportedLabel, children: "error" }) }));
    }
    if (field.typeName === 'number') {
        return (jsx_runtime_1.jsx("span", { style: wrapperStyle, children: jsx_runtime_1.jsx(TimelineNumberField, { field: field, canUpdate: canUpdate, onSave: onSave, onSavingChange: onSavingChange, onDragValueChange: onDragValueChange, onDragEnd: onDragEnd }) }));
    }
    return (jsx_runtime_1.jsx("span", { style: { ...unsupportedLabel, fontStyle: 'normal' }, children: String(field.currentValue) }));
};
exports.TimelineFieldValue = TimelineFieldValue;
const TimelineFieldSavingSpinner = ({ saving }) => {
    if (!saving) {
        return null;
    }
    return jsx_runtime_1.jsx(Spinner_1.Spinner, { duration: 0.5, size: 12 });
};
exports.TimelineFieldSavingSpinner = TimelineFieldSavingSpinner;
