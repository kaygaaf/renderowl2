"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimelineExpandedSection = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const remotion_1 = require("remotion");
const colors_1 = require("../../helpers/colors");
const timeline_layout_1 = require("../../helpers/timeline-layout");
const call_api_1 = require("../call-api");
const TimelineSchemaField_1 = require("./TimelineSchemaField");
const expandedSectionBase = {
    color: 'white',
    fontFamily: 'Arial, Helvetica, sans-serif',
    fontSize: 12,
    display: 'flex',
    flexDirection: 'column',
    paddingLeft: 28,
    paddingRight: 10,
    borderBottom: `1px solid ${colors_1.TIMELINE_TRACK_SEPARATOR}`,
};
const fieldRow = {
    display: 'flex',
    alignItems: 'center',
    gap: 8,
};
const fieldName = {
    fontSize: 12,
};
const fieldLabelRow = {
    flex: 1,
    display: 'flex',
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
};
const TimelineFieldRow = ({ field, onSave, onDragValueChange, onDragEnd, propStatus }) => {
    var _a;
    const [saving, setSaving] = (0, react_1.useState)(false);
    const onSavingChange = (0, react_1.useCallback)((s) => {
        setSaving(s);
    }, []);
    return (jsx_runtime_1.jsxs("div", { style: { ...fieldRow, height: field.rowHeight }, children: [
            jsx_runtime_1.jsxs("div", { style: fieldLabelRow, children: [
                    jsx_runtime_1.jsx("span", { style: fieldName, children: field.key }), jsx_runtime_1.jsx(TimelineSchemaField_1.TimelineFieldSavingSpinner, { saving: saving })
                ] }), jsx_runtime_1.jsx(TimelineSchemaField_1.TimelineFieldValue, { field: field, propStatus: propStatus, onSave: onSave, onSavingChange: onSavingChange, onDragValueChange: onDragValueChange, onDragEnd: onDragEnd, canUpdate: (_a = propStatus === null || propStatus === void 0 ? void 0 : propStatus.canUpdate) !== null && _a !== void 0 ? _a : false })
        ] }));
};
const TimelineExpandedSection = ({ sequence, originalLocation }) => {
    const [propStatuses, setPropStatuses] = (0, react_1.useState)(null);
    const schemaFields = (0, react_1.useMemo)(() => (0, timeline_layout_1.getSchemaFields)(sequence.controls), [sequence.controls]);
    const validatedLocation = (0, react_1.useMemo)(() => {
        var _a;
        if (!originalLocation ||
            !originalLocation.source ||
            !originalLocation.line) {
            return null;
        }
        return {
            source: originalLocation.source,
            line: originalLocation.line,
            column: (_a = originalLocation.column) !== null && _a !== void 0 ? _a : 0,
        };
    }, [originalLocation]);
    (0, react_1.useEffect)(() => {
        if (!sequence.controls || !validatedLocation || !schemaFields) {
            setPropStatuses(null);
            return;
        }
        (0, call_api_1.callApi)('/api/can-update-sequence-props', {
            fileName: validatedLocation.source,
            line: validatedLocation.line,
            column: validatedLocation.column,
            keys: schemaFields.map((f) => f.key),
        })
            .then((result) => {
            if (result.canUpdate) {
                setPropStatuses(result.props);
            }
            else {
                setPropStatuses(null);
            }
        })
            .catch(() => {
            setPropStatuses(null);
        });
    }, [sequence.controls, validatedLocation, schemaFields]);
    const expandedHeight = (0, react_1.useMemo)(() => (0, timeline_layout_1.getExpandedTrackHeight)(sequence.controls), [sequence.controls]);
    const { setOverride, clearOverrides } = (0, react_1.useContext)(remotion_1.Internals.SequenceControlOverrideContext);
    const onSave = (0, react_1.useCallback)((key, value) => {
        if (!propStatuses || !validatedLocation) {
            return Promise.reject(new Error('Cannot save'));
        }
        const status = propStatuses[key];
        if (!status || !status.canUpdate) {
            return Promise.reject(new Error('Cannot save'));
        }
        return (0, call_api_1.callApi)('/api/save-sequence-props', {
            fileName: validatedLocation.source,
            line: validatedLocation.line,
            column: validatedLocation.column,
            key,
            value: JSON.stringify(value),
            enumPaths: [],
        }).then(() => undefined);
    }, [propStatuses, validatedLocation]);
    const onDragValueChange = (0, react_1.useCallback)((key, value) => {
        setOverride(sequence.id, key, value);
    }, [setOverride, sequence.id]);
    const onDragEnd = (0, react_1.useCallback)(() => {
        clearOverrides(sequence.id);
    }, [clearOverrides, sequence.id]);
    return (jsx_runtime_1.jsx("div", { style: { ...expandedSectionBase, height: expandedHeight }, children: schemaFields
            ? schemaFields.map((field) => {
                var _a;
                return (jsx_runtime_1.jsx(TimelineFieldRow, { field: field, propStatus: (_a = propStatuses === null || propStatuses === void 0 ? void 0 : propStatuses[field.key]) !== null && _a !== void 0 ? _a : null, onSave: onSave, onDragValueChange: onDragValueChange, onDragEnd: onDragEnd }, field.key));
            })
            : 'No schema' }));
};
exports.TimelineExpandedSection = TimelineExpandedSection;
